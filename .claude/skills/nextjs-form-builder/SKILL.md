---
name: nextjs-form-builder
description: Generate production-ready Next.js forms with Zod validation, React Hook Form integration, server actions, accessibility, error handling, loading states, and progressive enhancement. Use when creating login forms, registration, contact forms, search filters, checkout forms, profile editors, multi-step wizards, or any data input interface. Outputs forms that are type-safe, accessible, handle edge cases, validate on client and server, and provide excellent UX with loading states and error feedback.
---

# Next.js Form Builder

Generate complete, production-ready form solutions with validation, error handling, accessibility, and seamless Next.js integration.

## Core Principles

**Forms Generated by This Skill:**

- ✅ Type-safe with TypeScript and Zod
- ✅ Accessible (WCAG 2.1 AA compliant)
- ✅ Client & server validation
- ✅ Progressive enhancement (works without JS)
- ✅ Loading states and optimistic updates
- ✅ Error handling with user-friendly messages
- ✅ Keyboard navigation support
- ✅ Mobile-responsive design
- ✅ Integration with Next.js App Router
- ✅ Security best practices (CSRF, rate limiting awareness)

## Form Types & When to Use

### 1. Server Action Forms (Recommended Default)

**Use when:** Standard form submission, progressive enhancement needed, SEO important

**Benefits:**

- Works without JavaScript
- Automatic revalidation
- Simple implementation
- Built-in loading states with `useFormState`
- Better for SEO

**Example use cases:**

- Contact forms
- Login/registration
- Profile updates
- Comment submission
- Newsletter signup

### 2. Client-Side Forms (React Hook Form)

**Use when:** Real-time validation needed, complex field interactions, file uploads with preview

**Benefits:**

- Instant validation feedback
- Better UX for complex forms
- Conditional fields
- Field arrays (dynamic add/remove)
- Better performance (fewer re-renders)

**Example use cases:**

- Multi-step wizards
- Dynamic product configurators
- Forms with conditional logic
- File upload with preview
- Real-time search/filter

### 3. Hybrid Forms (Best of Both)

**Use when:** Need real-time UX + progressive enhancement

**Benefits:**

- Real-time validation
- Works without JS
- Best user experience
- Handles all edge cases

**Example use cases:**

- Payment forms
- Checkout flows
- Critical business forms
- High-traffic forms

## Core Implementation Patterns

### Pattern 1: Server Action Form (Progressive Enhancement)

**Structure:**

```tsx
// app/actions.ts
"use server";

import { z } from "zod";
import { revalidatePath } from "next/cache";

const contactSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  message: z.string().min(10, "Message must be at least 10 characters"),
});

export async function submitContact(prevState: any, formData: FormData) {
  // Extract and validate
  const validatedFields = contactSchema.safeParse({
    name: formData.get("name"),
    email: formData.get("email"),
    message: formData.get("message"),
  });

  // Return errors if validation fails
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: "Validation failed. Please check your input.",
    };
  }

  try {
    // Process the form (save to DB, send email, etc.)
    await saveContactSubmission(validatedFields.data);

    // Revalidate relevant paths
    revalidatePath("/contact");

    return {
      success: true,
      message: "Thank you! We'll get back to you soon.",
    };
  } catch (error) {
    return {
      error: "Something went wrong. Please try again later.",
    };
  }
}
```

**Component:**

```tsx
"use client";

import { useFormState, useFormStatus } from "react-dom";
import { submitContact } from "@/app/actions";

function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button
      type="submit"
      disabled={pending}
      className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
    >
      {pending ? "Sending..." : "Send Message"}
    </button>
  );
}

export default function ContactForm() {
  const [state, formAction] = useFormState(submitContact, null);

  return (
    <form action={formAction} className="space-y-6 max-w-md mx-auto">
      {/* Success Message */}
      {state?.success && (
        <div
          className="p-4 bg-green-50 border border-green-200 rounded text-green-800"
          role="alert"
        >
          {state.message}
        </div>
      )}

      {/* Error Message */}
      {state?.error && (
        <div
          className="p-4 bg-red-50 border border-red-200 rounded text-red-800"
          role="alert"
        >
          {state.error}
        </div>
      )}

      {/* Name Field */}
      <div>
        <label
          htmlFor="name"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Name
        </label>
        <input
          id="name"
          name="name"
          type="text"
          required
          aria-invalid={state?.errors?.name ? "true" : "false"}
          aria-describedby={state?.errors?.name ? "name-error" : undefined}
          className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
        {state?.errors?.name && (
          <p id="name-error" className="mt-1 text-sm text-red-600">
            {state.errors.name[0]}
          </p>
        )}
      </div>

      {/* Email Field */}
      <div>
        <label
          htmlFor="email"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Email
        </label>
        <input
          id="email"
          name="email"
          type="email"
          required
          aria-invalid={state?.errors?.email ? "true" : "false"}
          aria-describedby={state?.errors?.email ? "email-error" : undefined}
          className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
        {state?.errors?.email && (
          <p id="email-error" className="mt-1 text-sm text-red-600">
            {state.errors.email[0]}
          </p>
        )}
      </div>

      {/* Message Field */}
      <div>
        <label
          htmlFor="message"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Message
        </label>
        <textarea
          id="message"
          name="message"
          rows={4}
          required
          aria-invalid={state?.errors?.message ? "true" : "false"}
          aria-describedby={
            state?.errors?.message ? "message-error" : undefined
          }
          className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
        {state?.errors?.message && (
          <p id="message-error" className="mt-1 text-sm text-red-600">
            {state.errors.message[0]}
          </p>
        )}
      </div>

      <SubmitButton />
    </form>
  );
}
```

### Pattern 2: Client-Side Form (React Hook Form)

**Structure:**

```tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useState } from "react";

const loginSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  rememberMe: z.boolean().optional(),
});

type LoginFormData = z.infer<typeof loginSchema>;

export default function LoginForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    mode: "onBlur", // Validate on blur for better UX
  });

  const onSubmit = async (data: LoginFormData) => {
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Login failed");
      }

      // Success - redirect or update UI
      window.location.href = "/dashboard";
    } catch (error) {
      setSubmitError(
        error instanceof Error ? error.message : "An error occurred"
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      className="space-y-6 max-w-md mx-auto"
      noValidate
    >
      {/* Submit Error */}
      {submitError && (
        <div
          className="p-4 bg-red-50 border border-red-200 rounded text-red-800"
          role="alert"
        >
          {submitError}
        </div>
      )}

      {/* Email Field */}
      <div>
        <label
          htmlFor="email"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Email
        </label>
        <input
          id="email"
          type="email"
          {...register("email")}
          aria-invalid={errors.email ? "true" : "false"}
          aria-describedby={errors.email ? "email-error" : undefined}
          className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
        {errors.email && (
          <p id="email-error" className="mt-1 text-sm text-red-600">
            {errors.email.message}
          </p>
        )}
      </div>

      {/* Password Field */}
      <div>
        <label
          htmlFor="password"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Password
        </label>
        <input
          id="password"
          type="password"
          {...register("password")}
          aria-invalid={errors.password ? "true" : "false"}
          aria-describedby={errors.password ? "password-error" : undefined}
          className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
        {errors.password && (
          <p id="password-error" className="mt-1 text-sm text-red-600">
            {errors.password.message}
          </p>
        )}
      </div>

      {/* Remember Me Checkbox */}
      <div className="flex items-center">
        <input
          id="rememberMe"
          type="checkbox"
          {...register("rememberMe")}
          className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
        />
        <label
          htmlFor="rememberMe"
          className="ml-2 block text-sm text-gray-700"
        >
          Remember me
        </label>
      </div>

      <button
        type="submit"
        disabled={isSubmitting}
        className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
      >
        {isSubmitting ? "Logging in..." : "Log In"}
      </button>
    </form>
  );
}
```

### Pattern 3: Multi-Step Form (Wizard)

**Structure:**

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

// Step schemas
const step1Schema = z.object({
  firstName: z.string().min(2, "First name required"),
  lastName: z.string().min(2, "Last name required"),
  email: z.string().email("Invalid email"),
});

const step2Schema = z.object({
  company: z.string().min(2, "Company name required"),
  role: z.string().min(2, "Role required"),
  phoneNumber: z.string().regex(/^\+?[1-9]\d{1,14}$/, "Invalid phone number"),
});

const step3Schema = z.object({
  interests: z.array(z.string()).min(1, "Select at least one interest"),
  newsletter: z.boolean(),
});

// Combined schema for final validation
const fullSchema = z.object({
  ...step1Schema.shape,
  ...step2Schema.shape,
  ...step3Schema.shape,
});

type FormData = z.infer<typeof fullSchema>;

const STEPS = [
  { title: "Personal Info", schema: step1Schema },
  { title: "Professional Info", schema: step2Schema },
  { title: "Preferences", schema: step3Schema },
];

export default function MultiStepForm() {
  const [currentStep, setCurrentStep] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const currentSchema = STEPS[currentStep].schema;

  const {
    register,
    handleSubmit,
    formState: { errors },
    trigger,
    getValues,
  } = useForm<FormData>({
    resolver: zodResolver(currentSchema),
    mode: "onBlur",
  });

  const nextStep = async () => {
    const isValid = await trigger();
    if (isValid && currentStep < STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const onSubmit = async (data: FormData) => {
    setIsSubmitting(true);

    try {
      // Validate all steps with full schema
      const validated = fullSchema.parse(data);

      const response = await fetch("/api/registration", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(validated),
      });

      if (!response.ok) throw new Error("Registration failed");

      // Success - redirect or show success message
      window.location.href = "/welcome";
    } catch (error) {
      console.error("Registration error:", error);
      alert("Registration failed. Please try again.");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      {/* Progress Indicator */}
      <div className="mb-8">
        <div className="flex justify-between items-center">
          {STEPS.map((step, index) => (
            <div key={index} className="flex items-center">
              <div
                className={`w-10 h-10 rounded-full flex items-center justify-center font-semibold ${
                  index <= currentStep
                    ? "bg-blue-600 text-white"
                    : "bg-gray-200 text-gray-600"
                }`}
              >
                {index + 1}
              </div>
              <span className="ml-2 text-sm font-medium">{step.title}</span>
              {index < STEPS.length - 1 && (
                <div
                  className={`w-16 h-1 mx-4 ${
                    index < currentStep ? "bg-blue-600" : "bg-gray-200"
                  }`}
                />
              )}
            </div>
          ))}
        </div>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
        {/* Step 1: Personal Info */}
        {currentStep === 0 && (
          <>
            <div>
              <label
                htmlFor="firstName"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                First Name
              </label>
              <input
                id="firstName"
                type="text"
                {...register("firstName")}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              {errors.firstName && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.firstName.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor="lastName"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Last Name
              </label>
              <input
                id="lastName"
                type="text"
                {...register("lastName")}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              {errors.lastName && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.lastName.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Email
              </label>
              <input
                id="email"
                type="email"
                {...register("email")}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              {errors.email && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.email.message}
                </p>
              )}
            </div>
          </>
        )}

        {/* Step 2: Professional Info */}
        {currentStep === 1 && (
          <>
            <div>
              <label
                htmlFor="company"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Company
              </label>
              <input
                id="company"
                type="text"
                {...register("company")}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              {errors.company && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.company.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor="role"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Role
              </label>
              <input
                id="role"
                type="text"
                {...register("role")}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              {errors.role && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.role.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor="phoneNumber"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Phone Number
              </label>
              <input
                id="phoneNumber"
                type="tel"
                {...register("phoneNumber")}
                placeholder="+1234567890"
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              {errors.phoneNumber && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.phoneNumber.message}
                </p>
              )}
            </div>
          </>
        )}

        {/* Step 3: Preferences */}
        {currentStep === 2 && (
          <>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Interests (select at least one)
              </label>
              <div className="space-y-2">
                {["Technology", "Marketing", "Design", "Business", "Other"].map(
                  (interest) => (
                    <div key={interest} className="flex items-center">
                      <input
                        id={interest}
                        type="checkbox"
                        value={interest}
                        {...register("interests")}
                        className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                      />
                      <label
                        htmlFor={interest}
                        className="ml-2 text-sm text-gray-700"
                      >
                        {interest}
                      </label>
                    </div>
                  )
                )}
              </div>
              {errors.interests && (
                <p className="mt-1 text-sm text-red-600">
                  {errors.interests.message}
                </p>
              )}
            </div>

            <div className="flex items-center">
              <input
                id="newsletter"
                type="checkbox"
                {...register("newsletter")}
                className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
              />
              <label
                htmlFor="newsletter"
                className="ml-2 text-sm text-gray-700"
              >
                Subscribe to newsletter
              </label>
            </div>
          </>
        )}

        {/* Navigation Buttons */}
        <div className="flex justify-between pt-6">
          <button
            type="button"
            onClick={prevStep}
            disabled={currentStep === 0}
            className="px-6 py-2 border border-gray-300 rounded text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Previous
          </button>

          {currentStep < STEPS.length - 1 ? (
            <button
              type="button"
              onClick={nextStep}
              className="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            >
              Next
            </button>
          ) : (
            <button
              type="submit"
              disabled={isSubmitting}
              className="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            >
              {isSubmitting ? "Submitting..." : "Submit"}
            </button>
          )}
        </div>
      </form>
    </div>
  );
}
```

## Advanced Patterns

### Pattern 4: File Upload Form

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ACCEPTED_IMAGE_TYPES = [
  "image/jpeg",
  "image/jpg",
  "image/png",
  "image/webp",
];

const profileSchema = z.object({
  name: z.string().min(2, "Name required"),
  bio: z.string().max(500, "Bio must be less than 500 characters"),
  avatar: z
    .any()
    .refine((files) => files?.length > 0, "Avatar is required")
    .refine(
      (files) => files?.[0]?.size <= MAX_FILE_SIZE,
      "Max file size is 5MB"
    )
    .refine(
      (files) => ACCEPTED_IMAGE_TYPES.includes(files?.[0]?.type),
      "Only .jpg, .jpeg, .png and .webp formats are supported"
    ),
});

type ProfileFormData = z.infer<typeof profileSchema>;

export default function ProfileForm() {
  const [preview, setPreview] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
  } = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
  });

  // Watch avatar field for preview
  const avatarFile = watch("avatar");

  // Update preview when file changes
  useState(() => {
    if (avatarFile?.length > 0) {
      const file = avatarFile[0];
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  });

  const onSubmit = async (data: ProfileFormData) => {
    setIsSubmitting(true);

    try {
      const formData = new FormData();
      formData.append("name", data.name);
      formData.append("bio", data.bio);
      formData.append("avatar", data.avatar[0]);

      const response = await fetch("/api/profile", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) throw new Error("Upload failed");

      alert("Profile updated successfully!");
    } catch (error) {
      alert("Failed to update profile. Please try again.");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      className="space-y-6 max-w-md mx-auto"
    >
      {/* Name Field */}
      <div>
        <label
          htmlFor="name"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Name
        </label>
        <input
          id="name"
          type="text"
          {...register("name")}
          className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        {errors.name && (
          <p className="mt-1 text-sm text-red-600">{errors.name.message}</p>
        )}
      </div>

      {/* Bio Field */}
      <div>
        <label
          htmlFor="bio"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Bio
        </label>
        <textarea
          id="bio"
          rows={4}
          {...register("bio")}
          className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        {errors.bio && (
          <p className="mt-1 text-sm text-red-600">{errors.bio.message}</p>
        )}
      </div>

      {/* Avatar Upload with Preview */}
      <div>
        <label
          htmlFor="avatar"
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          Avatar
        </label>
        <div className="flex items-center space-x-4">
          {preview && (
            <img
              src={preview}
              alt="Avatar preview"
              className="w-20 h-20 rounded-full object-cover"
            />
          )}
          <input
            id="avatar"
            type="file"
            accept="image/*"
            {...register("avatar")}
            className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
          />
        </div>
        {errors.avatar && (
          <p className="mt-1 text-sm text-red-600">
            {errors.avatar.message as string}
          </p>
        )}
      </div>

      <button
        type="submit"
        disabled={isSubmitting}
        className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
      >
        {isSubmitting ? "Uploading..." : "Update Profile"}
      </button>
    </form>
  );
}
```

### Pattern 5: Dynamic Field Array

```tsx
"use client";

import { useFieldArray, useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const experienceSchema = z.object({
  experiences: z
    .array(
      z.object({
        company: z.string().min(2, "Company name required"),
        role: z.string().min(2, "Role required"),
        years: z
          .number()
          .min(0, "Years must be positive")
          .max(50, "Invalid years"),
      })
    )
    .min(1, "At least one experience is required"),
});

type ExperienceFormData = z.infer<typeof experienceSchema>;

export default function ExperienceForm() {
  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<ExperienceFormData>({
    resolver: zodResolver(experienceSchema),
    defaultValues: {
      experiences: [{ company: "", role: "", years: 0 }],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "experiences",
  });

  const onSubmit = (data: ExperienceFormData) => {
    console.log(data);
    // Process form data
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      className="space-y-6 max-w-2xl mx-auto"
    >
      <h2 className="text-2xl font-bold">Work Experience</h2>

      {fields.map((field, index) => (
        <div
          key={field.id}
          className="p-4 border border-gray-200 rounded space-y-4"
        >
          <div className="flex justify-between items-center">
            <h3 className="font-medium">Experience {index + 1}</h3>
            {fields.length > 1 && (
              <button
                type="button"
                onClick={() => remove(index)}
                className="text-red-600 hover:text-red-800 text-sm"
              >
                Remove
              </button>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Company
            </label>
            <input
              {...register(`experiences.${index}.company`)}
              className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            {errors.experiences?.[index]?.company && (
              <p className="mt-1 text-sm text-red-600">
                {errors.experiences[index]?.company?.message}
              </p>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Role
            </label>
            <input
              {...register(`experiences.${index}.role`)}
              className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            {errors.experiences?.[index]?.role && (
              <p className="mt-1 text-sm text-red-600">
                {errors.experiences[index]?.role?.message}
              </p>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Years
            </label>
            <input
              type="number"
              {...register(`experiences.${index}.years`, {
                valueAsNumber: true,
              })}
              className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            {errors.experiences?.[index]?.years && (
              <p className="mt-1 text-sm text-red-600">
                {errors.experiences[index]?.years?.message}
              </p>
            )}
          </div>
        </div>
      ))}

      <button
        type="button"
        onClick={() => append({ company: "", role: "", years: 0 })}
        className="px-4 py-2 border border-blue-600 text-blue-600 rounded hover:bg-blue-50"
      >
        Add Experience
      </button>

      {errors.experiences?.root && (
        <p className="text-sm text-red-600">
          {errors.experiences.root.message}
        </p>
      )}

      <button
        type="submit"
        className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
      >
        Save Experience
      </button>
    </form>
  );
}
```

## Validation Best Practices

### 1. Zod Schema Patterns

**Email validation:**

```typescript
email: z.string().email("Invalid email address");
```

**Password validation:**

```typescript
password: z.string()
  .min(8, "Password must be at least 8 characters")
  .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
  .regex(/[a-z]/, "Password must contain at least one lowercase letter")
  .regex(/[0-9]/, "Password must contain at least one number")
  .regex(
    /[^A-Za-z0-9]/,
    "Password must contain at least one special character"
  );
```

**Password confirmation:**

```typescript
const schema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });
```

**Phone number validation:**

```typescript
phone: z.string().regex(/^\+?[1-9]\d{1,14}$/, "Invalid phone number");
```

**URL validation:**

```typescript
website: z.string().url("Invalid URL");
```

**Date validation:**

```typescript
birthDate: z.string()
  .refine(
    (date) => new Date(date) < new Date(),
    "Birth date must be in the past"
  )
  .refine((date) => {
    const age = new Date().getFullYear() - new Date(date).getFullYear();
    return age >= 18;
  }, "Must be at least 18 years old");
```

**Custom async validation:**

```typescript
email: z.string()
  .email()
  .refine(async (email) => {
    const exists = await checkEmailAvailability(email);
    return !exists;
  }, "Email already taken");
```

### 2. Error Message Best Practices

**Good error messages:**

- ✅ "Email address is required"
- ✅ "Password must be at least 8 characters"
- ✅ "Please enter a valid phone number (e.g., +1234567890)"

**Bad error messages:**

- ❌ "Invalid input"
- ❌ "Error"
- ❌ "Required"

**Guidelines:**

- Be specific about what went wrong
- Provide examples when format is expected
- Use positive language ("Please enter" vs "You didn't enter")
- Keep messages concise (under 100 characters)

## Accessibility Requirements

### WCAG 2.1 AA Compliance Checklist

**✅ Labels:**

- Every input has a visible label
- Labels are associated using `htmlFor` and `id`
- Labels are descriptive

**✅ Error Handling:**

- Errors are announced to screen readers using `aria-describedby`
- Errors are marked with `aria-invalid="true"`
- Focus moves to first error field on submission

**✅ Keyboard Navigation:**

- All interactive elements are keyboard accessible
- Tab order is logical
- Focus indicators are visible
- Form can be submitted with Enter key

**✅ Required Fields:**

- Required fields are marked visually (asterisk or "required")
- Required fields use `required` attribute or `aria-required="true"`

**✅ Instructions:**

- Format requirements are provided before field
- Help text is associated with `aria-describedby`

**✅ Success/Error Messages:**

- Use `role="alert"` for important messages
- Messages are clearly distinguishable (color + icon)

### Keyboard Shortcuts

Implement these for better UX:

```tsx
useEffect(() => {
  const handleKeyPress = (e: KeyboardEvent) => {
    // Ctrl+Enter to submit
    if (e.ctrlKey && e.key === "Enter") {
      handleSubmit(onSubmit)();
    }

    // Escape to reset
    if (e.key === "Escape") {
      reset();
    }
  };

  window.addEventListener("keydown", handleKeyPress);
  return () => window.removeEventListener("keydown", handleKeyPress);
}, [handleSubmit, reset]);
```

## Security Considerations

### 1. CSRF Protection

**For Server Actions:**
Next.js handles CSRF automatically with server actions.

**For API Routes:**

```tsx
// Use next-csrf or similar
import { csrf } from "@/lib/csrf";

export async function POST(request: NextRequest) {
  // Verify CSRF token
  const isValid = await csrf.verify(request);
  if (!isValid) {
    return NextResponse.json({ error: "Invalid CSRF token" }, { status: 403 });
  }

  // Process form
}
```

### 2. Rate Limiting

```typescript
import { ratelimit } from "@/lib/redis";

export async function submitForm(prevState: any, formData: FormData) {
  const ip = headers().get("x-forwarded-for") ?? "127.0.0.1";

  const { success } = await ratelimit.limit(ip);
  if (!success) {
    return { error: "Too many requests. Please try again later." };
  }

  // Process form
}
```

### 3. Input Sanitization

```typescript
import DOMPurify from "isomorphic-dompurify";

// For rich text/HTML content
const sanitizedContent = DOMPurify.sanitize(formData.get("content"));

// For regular text, Zod validation + React escaping is sufficient
```

### 4. File Upload Security

```typescript
// Validate file type on server
const allowedTypes = ["image/jpeg", "image/png"];
if (!allowedTypes.includes(file.type)) {
  return { error: "Invalid file type" };
}

// Validate file size
const maxSize = 5 * 1024 * 1024; // 5MB
if (file.size > maxSize) {
  return { error: "File too large" };
}

// Generate secure filename
const secureFilename = `${crypto.randomUUID()}-${file.name}`;
```

## Performance Optimization

### 1. Debounced Validation

For expensive validation (API calls):

```tsx
import { useDebounce } from "@/hooks/useDebounce";

const debouncedEmail = useDebounce(email, 500);

useEffect(() => {
  if (debouncedEmail) {
    checkEmailAvailability(debouncedEmail);
  }
}, [debouncedEmail]);
```

### 2. Lazy Loading

For large forms with many fields:

```tsx
import dynamic from "next/dynamic";

const HeavyFormSection = dynamic(() => import("./HeavyFormSection"), {
  loading: () => <div>Loading...</div>,
  ssr: false,
});
```

### 3. Optimistic Updates

For better UX:

```tsx
const [optimisticData, setOptimisticData] = useState(data);

const handleSubmit = async (formData) => {
  // Update UI immediately
  setOptimisticData(formData);

  try {
    await submitForm(formData);
  } catch (error) {
    // Revert on error
    setOptimisticData(data);
  }
};
```

## Testing Patterns

### Unit Testing Forms

```typescript
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import ContactForm from "./ContactForm";

describe("ContactForm", () => {
  it("shows validation errors on submit", async () => {
    render(<ContactForm />);

    const submitButton = screen.getByRole("button", { name: /send/i });
    await userEvent.click(submitButton);

    expect(screen.getByText(/name is required/i)).toBeInTheDocument();
  });

  it("submits form with valid data", async () => {
    render(<ContactForm />);

    await userEvent.type(screen.getByLabelText(/name/i), "John Doe");
    await userEvent.type(screen.getByLabelText(/email/i), "john@example.com");
    await userEvent.type(
      screen.getByLabelText(/message/i),
      "Test message here"
    );

    await userEvent.click(screen.getByRole("button", { name: /send/i }));

    await waitFor(() => {
      expect(screen.getByText(/thank you/i)).toBeInTheDocument();
    });
  });
});
```

## Common Patterns Summary

### When to Use Each Pattern

| Pattern                | Use Case                                   | Progressive Enhancement | Complexity  |
| ---------------------- | ------------------------------------------ | ----------------------- | ----------- |
| Server Action Form     | Contact, Login, Simple CRUD                | ✅ Yes                  | Low         |
| Client-Side Form (RHF) | Real-time validation, Complex interactions | ❌ No                   | Medium      |
| Multi-Step Form        | Registration, Onboarding                   | ❌ No                   | High        |
| File Upload Form       | Profile picture, Document upload           | ⚠️ Partial              | Medium      |
| Dynamic Field Array    | Education history, Multiple addresses      | ❌ No                   | Medium-High |

## Dependencies Required

```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.48.0",
    "zod": "^3.22.4",
    "@hookform/resolvers": "^3.3.2"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "typescript": "^5.0.0"
  }
}
```

**Installation:**

```bash
npm install react-hook-form zod @hookform/resolvers
```

## Constraints

**Do NOT:**

- Skip accessibility attributes (labels, aria-\*)
- Forget to validate on both client and server
- Use inline event handlers in JSX (use proper handlers)
- Store sensitive data in form state unnecessarily
- Skip loading states during submission
- Forget to handle edge cases (network errors, timeouts)
- Use `any` types for form data
- Skip error boundaries for forms that might crash
- Forget mobile responsiveness
- Omit success feedback after submission

## Success Criteria

A successful form implementation:

- ✅ Validates input on client and server
- ✅ Shows clear, helpful error messages
- ✅ Provides loading feedback during submission
- ✅ Is fully keyboard accessible
- ✅ Works on mobile devices
- ✅ Handles network errors gracefully
- ✅ Uses progressive enhancement (when appropriate)
- ✅ Is type-safe with TypeScript
- ✅ Follows WCAG 2.1 AA guidelines
- ✅ Provides success feedback
- ✅ Prevents double submission
- ✅ Maintains form state during errors

## Assumptions

Unless stated otherwise, assume:

- Next.js 14+ with App Router
- TypeScript enabled
- Tailwind CSS configured
- React Hook Form for client-side forms
- Zod for validation
- Server actions available for form submission

## Quick Reference

**Choose Server Action Form when:**

- Simple form (< 5 fields)
- SEO important
- Progressive enhancement needed
- Don't need real-time validation

**Choose Client-Side Form when:**

- Complex validation rules
- Real-time feedback needed
- Conditional field logic
- File upload with preview
- Multi-step wizard

**Always Include:**

- Labels with `htmlFor`
- Error messages with `aria-describedby`
- Loading states
- Success feedback
- Focus management
- Keyboard support
